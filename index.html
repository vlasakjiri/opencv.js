<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Hello OpenCV.js</title>
</head>

<body>

    <h2>Hello OpenCV.js</h2>
    <p id="status">OpenCV.js is loading...</p>
    <div>
        <video id="videoInput" width="800" height="450" muted controls src="3.mp4"></video>

    </div>
    <div>
        <canvas id="canvasOutput" width="1200" height="725"></canvas>
    </div>
    <div>
        <canvas id="canvasBlack" width="800" height="450"></canvas>
    </div>
    <script async src="opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <script src="kalman-filter.js"></script>
    <script>
        var { KalmanFilter } = kalmanFilter;

        const canvas = document.getElementById("canvasOutput");
        const canvasBlack = document.getElementById("canvasBlack");

        const rect = canvas.getBoundingClientRect();


        function MinIdx2d(arr, deleted_landmarks_idx, deleted_centroids_idx)
        {
            let min = Number.MAX_VALUE;
            let min_idx;
            arr.forEach((outer, outer_idx) =>
            {
                if (deleted_landmarks_idx.includes(outer_idx))
                {
                    return;
                }
                outer.forEach((inner, innerIdx) =>
                {
                    if (deleted_centroids_idx.includes(innerIdx))
                    {
                        return;
                    }
                    if (inner < min)
                    {
                        min = inner;
                        min_idx = [outer_idx, innerIdx]
                    }
                });
            });
            return min_idx
        }
        function onOpenCvReady()
        {
            cv['onRuntimeInitialized'] = () =>
            {
                document.getElementById('status').innerHTML = 'OpenCV.js is ready.';

                let video = document.getElementById('videoInput');
                let cap = new cv.VideoCapture(video);


                let frame = new cv.Mat(video.height, video.width, cv.CV_8UC4);
                let frame_hsv = new cv.Mat(video.height, video.width, cv.CV_8UC4);


                const FPS = 60;

                // schedule the first one.
                setTimeout(processVideo, 0);


                let Hs = [];
                let Ss = [];
                let Vs = [];

                landmarks = [];
                kalman_filters = [];
                kalman_previous_corrected = [];
                kalman_predictions = [];

                canvas.addEventListener("click", function (event)
                {
                    const x = event.clientX - canvas.offsetLeft + window.pageXOffset;
                    const y = event.clientY - canvas.offsetTop + window.pageYOffset;
                    let point = { "x": x, "y": y }
                    landmarks.push(point);
                    kalman_filters.push(new KalmanFilter({
                        observation: 2,
                        dynamic: 'constant-speed'
                    }));
                    // matched_landmarks.push(point);
                    // const ctx = canvas.getContext("2d");
                    // const pixelData = ctx.getImageData(x, y, 1, 1).data;

                    // console.log("Pixel value at (" + x + ", " + y + "): " + pixelData);

                    let H = frame_hsv.ucharAt(y, x * frame_hsv.channels());
                    let S = frame_hsv.ucharAt(y, x * frame_hsv.channels() + 1);
                    let V = frame_hsv.ucharAt(y, x * frame_hsv.channels() + 2);

                    Hs = Hs.concat(H);
                    Ss = Ss.concat(S);
                    Vs = Vs.concat(V);

                    // console.log("Pixel value at (" + x + ", " + y + "): H:" + H + " S:" + S + " V: " + V);
                    console.log(landmarks)
                    console.log(Hs)
                    console.log(Ss)
                    console.log(Vs)

                });
                let colors = [];
                for (let index = 0; index < 20; index++)
                {
                    colors.push(new cv.Scalar(parseInt(Math.random() * 255), parseInt(Math.random() * 255),
                        parseInt(Math.random() * 255), 255))

                }



                function processVideo()
                {
                    try
                    {
                        let begin = Date.now();

                        // start processing.
                        cap.read(frame);


                        // select good points
                        // let keypoints = simpleBlobDetector(frame, { faster: true, filterByInertia: false })
                        // for (const keypoint of keypoints)
                        // {
                        //     const center = new cv.Point(keypoint.pt.x, keypoint.pt.y)
                        //     cv.circle(frame, center, keypoint.size, [255, 0, 0, 255], 3)
                        // }
                        cv.cvtColor(frame, frame_hsv, cv.COLOR_RGB2HSV)
                        let low = new cv.Mat(frame_hsv.rows, frame_hsv.cols, frame_hsv.type(), [Math.min(...Hs) - 10, Math.min(...Ss, 100) - 5, Math.min(...Vs, 100) - 5, 0]);
                        let high = new cv.Mat(frame_hsv.rows, frame_hsv.cols, frame_hsv.type(), [Math.max(...Hs) + 10, 255, 255, 255]);



                        // Apply the threshold to each channel of the image
                        const thresholdMat = new cv.Mat();
                        cv.inRange(frame_hsv, low, high, thresholdMat);

                        let M = cv.Mat.ones(2, 2, cv.CV_8U);
                        let anchor = new cv.Point(-1, -1);
                        // // You can try more different parameters
                        // cv.erode(thresholdMat, thresholdMat, M, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());
                        cv.dilate(thresholdMat, thresholdMat, M, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());


                        let contours = new cv.MatVector();
                        let hierarchy = new cv.Mat();
                        // You can try more different parameters
                        cv.findContours(thresholdMat, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
                        // draw contours with random Scalar
                        let centroids = [];
                        let color = new cv.Scalar(0, 255, 0, 255);
                        for (let i = 0; i < contours.size(); ++i)
                        {

                            // cv.drawContours(frame, contours, i, color, 1, cv.LINE_8, hierarchy, 100);
                            let M = cv.moments(contours.get(i), false);
                            if (M.m00 == 0)
                            {
                                continue
                            }
                            let cx = M.m10 / M.m00
                            let cy = M.m01 / M.m00
                            centroids.push({ "x": cx, "y": cy });
                            cv.circle(frame, new cv.Point(cx, cy), 1, new cv.Scalar(0, 255, 0, 255), -1);


                        }
                        // console.log(centroids.length)

                        landmark_dists = [];
                        landmarks.forEach((point, landmark_idx) =>
                        {
                            kalman_predictions[landmark_idx] = kalman_filters[landmark_idx].predict({
                                previousCorrected: kalman_previous_corrected[landmark_idx]
                            })
                            // let x = point["x"];
                            // let y = point["y"];

                            let x = point["x"] + kalman_predictions[landmark_idx].mean[2];
                            let y = point["y"] + kalman_predictions[landmark_idx].mean[3];

                            let min_dist = Number.MAX_SAFE_INTEGER;
                            let min_centroid_idx;
                            landmark_dists.push([])
                            centroids.forEach((centroid, idx) =>
                            {
                                let dist = Math.pow(x - centroid["x"], 2) + Math.pow(y - centroid["y"], 2);
                                landmark_dists[landmark_idx].push(dist);
                                // if (dist < min_dist)
                                // {
                                //     min_dist = dist;
                                //     min_centroid_idx = idx;
                                // }
                            });
                            // if (min_centroid_idx != undefined)
                            // {
                            //     let cx = centroids[min_centroid_idx]["x"];
                            //     let cy = centroids[min_centroid_idx]["y"]
                            //     landmarks[landmark_idx] = centroids[min_centroid_idx];
                            //     centroids.splice(min_centroid_idx, 1)
                            //     cv.circle(frame, new cv.Point(cx, cy), 3, color, -1);
                            // }
                        });
                        let deleted_landmarks_idx = [];
                        let deleted_centroids_idx = [];

                        while (landmark_dists.length > 0)
                        {
                            let min_idx = MinIdx2d(landmark_dists, deleted_landmarks_idx, deleted_centroids_idx);
                            if (min_idx == undefined)
                            {
                                break;
                            }
                            let landmark_idx = min_idx[0];
                            let min_centroid_idx = min_idx[1];

                            deleted_landmarks_idx.push(landmark_idx);
                            deleted_centroids_idx.push(min_centroid_idx);

                            landmarks[landmark_idx] = centroids[min_centroid_idx];

                            const correctedState = kalman_filters[landmark_idx].correct({
                                predicted: kalman_predictions[landmark_idx],
                                observation: [centroids[min_centroid_idx]["x"], centroids[min_centroid_idx]["y"]]
                            });
                            kalman_previous_corrected[landmark_idx] = correctedState;

                            // landmark_dists.splice(landmark_idx, 1)
                            // for (let index = 0; index < landmark_dists.length; index++)
                            // {
                            //     landmark_dists[index].splice(min_centroid_idx, 1);
                            // }

                            let cx = centroids[min_centroid_idx]["x"];
                            let cy = centroids[min_centroid_idx]["y"]
                            cv.circle(frame, new cv.Point(cx, cy), 5, colors[landmark_idx], -1);



                        }


                        cv.imshow('canvasOutput', frame);
                        cv.imshow('canvasBlack', thresholdMat);

                        // schedule the next one.
                        let delay = 1000 / FPS - (Date.now() - begin);
                        low.delete();
                        high.delete();
                        thresholdMat.delete();
                        setTimeout(processVideo, delay);
                    } catch (err)
                    {
                        console.error(err);
                    }
                };
            };

        }
    </script>
</body>

</html>