<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Hello OpenCV.js</title>
</head>

<body>

    <h2>Hello OpenCV.js</h2>
    <p id="status">OpenCV.js is loading...</p>
    <div>
        <video id="videoInput" width="800" height="450" muted controls src="test.mp4"></video>

    </div>
    <div>
        <canvas id="canvasOutput" width="1200" height="725"></canvas>
    </div>
    <div>
        <canvas id="canvasBlack" width="800" height="450"></canvas>
    </div>
    <script async src="opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>

    <script>

        const canvas = document.getElementById("canvasOutput");
        const canvasBlack = document.getElementById("canvasBlack");

        const rect = canvas.getBoundingClientRect();



        function onOpenCvReady() {
            cv['onRuntimeInitialized'] = () => {
                document.getElementById('status').innerHTML = 'OpenCV.js is ready.';

                let video = document.getElementById('videoInput');
                let cap = new cv.VideoCapture(video);


                let frame = new cv.Mat(video.height, video.width, cv.CV_8UC4);
                let frame_hsv = new cv.Mat(video.height, video.width, cv.CV_8UC4);


                const FPS = 60;

                // schedule the first one.
                setTimeout(processVideo, 0);


                let Hs = [];
                let Ss = [];
                let Vs = [];

                landmarks = [];
                matched_landmarks = [];


                canvas.addEventListener("click", function (event) {
                    const x = event.clientX - canvas.offsetLeft + window.pageXOffset;
                    const y = event.clientY - canvas.offsetTop + window.pageYOffset;
                    let point = { "x": x, "y": y }
                    landmarks.push(point);
                    // matched_landmarks.push(point);
                    // const ctx = canvas.getContext("2d");
                    // const pixelData = ctx.getImageData(x, y, 1, 1).data;

                    // console.log("Pixel value at (" + x + ", " + y + "): " + pixelData);

                    let H = frame_hsv.ucharAt(y, x * frame_hsv.channels());
                    let S = frame_hsv.ucharAt(y, x * frame_hsv.channels() + 1);
                    let V = frame_hsv.ucharAt(y, x * frame_hsv.channels() + 2);

                    Hs = Hs.concat(H);
                    Ss = Ss.concat(S);
                    Vs = Vs.concat(V);

                    // console.log("Pixel value at (" + x + ", " + y + "): H:" + H + " S:" + S + " V: " + V);
                    console.log(landmarks)
                    console.log(Hs)
                    console.log(Ss)
                    console.log(Vs)

                });

                function processVideo() {
                    try {
                        let begin = Date.now();

                        // start processing.
                        cap.read(frame);


                        // select good points
                        // let keypoints = simpleBlobDetector(frame, { faster: true, filterByInertia: false })
                        // for (const keypoint of keypoints)
                        // {
                        //     const center = new cv.Point(keypoint.pt.x, keypoint.pt.y)
                        //     cv.circle(frame, center, keypoint.size, [255, 0, 0, 255], 3)
                        // }
                        cv.cvtColor(frame, frame_hsv, cv.COLOR_RGB2HSV)
                        let low = new cv.Mat(frame_hsv.rows, frame_hsv.cols, frame_hsv.type(), [Math.min(...Hs) - 10, Math.min(...Ss, 100) - 5, Math.min(...Vs, 100) - 5, 0]);
                        let high = new cv.Mat(frame_hsv.rows, frame_hsv.cols, frame_hsv.type(), [Math.max(...Hs) + 10, 255, 255, 255]);



                        // Apply the threshold to each channel of the image
                        const thresholdMat = new cv.Mat();
                        cv.inRange(frame_hsv, low, high, thresholdMat);

                        // let M = cv.Mat.ones(2, 2, cv.CV_8U);
                        // let anchor = new cv.Point(-1, -1);
                        // // You can try more different parameters
                        // cv.erode(thresholdMat, thresholdMat, M, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());

                        let contours = new cv.MatVector();
                        let hierarchy = new cv.Mat();
                        // You can try more different parameters
                        cv.findContours(thresholdMat, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
                        // draw contours with random Scalar
                        let centroids = [];
                        let color = new cv.Scalar(0, 255, 0, 255);
                        for (let i = 0; i < contours.size(); ++i) {

                            // cv.drawContours(frame, contours, i, color, 1, cv.LINE_8, hierarchy, 100);
                            let M = cv.moments(contours.get(i), false);
                            let cx = M.m10 / M.m00
                            let cy = M.m01 / M.m00
                            centroids.push({ "x": cx, "y": cy });
                            cv.circle(frame, new cv.Point(cx, cy), 1, new cv.Scalar(255, 0, 0, 255), -1);


                        }
                        // console.log(centroids.length)

                        landmarks.forEach((point, landmark_idx) => {
                            let x = point["x"];
                            let y = point["y"];

                            let min_dist = Number.MAX_SAFE_INTEGER;
                            let min_centroid_idx;
                            centroids.forEach((centroid, idx) => {
                                let dist = Math.pow(x - centroid["x"], 2) + Math.pow(y - centroid["y"], 2);
                                if (dist < min_dist) {
                                    min_dist = dist;
                                    min_centroid_idx = idx;
                                }
                            });
                            if (min_centroid_idx != undefined) {
                                let cx = centroids[min_centroid_idx]["x"];
                                let cy = centroids[min_centroid_idx]["y"]
                                landmarks[landmark_idx] = centroids[min_centroid_idx];
                                centroids.splice(min_centroid_idx, 1)
                                cv.circle(frame, new cv.Point(cx, cy), 3, color, -1);
                            }
                        });


                        cv.imshow('canvasOutput', frame);
                        cv.imshow('canvasBlack', thresholdMat);

                        // schedule the next one.
                        let delay = 1000 / FPS - (Date.now() - begin);
                        low.delete();
                        high.delete();
                        thresholdMat.delete();
                        setTimeout(processVideo, delay);
                    } catch (err) {
                        console.error(err);
                    }
                };
            };

        }
    </script>
</body>

</html>