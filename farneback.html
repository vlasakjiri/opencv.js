<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Hello OpenCV.js</title>
</head>

<body>

    <h2>Hello OpenCV.js</h2>
    <p id="status">OpenCV.js is loading...</p>
    <div>
        <video id="videoInput" width="800" height="450" muted controls src="paska.mp4"></video>

    </div>
    <div>
        <canvas id="canvasOutput" width="800" height="450"></canvas>
    </div>
    <script async src="opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>

    <script type="text/javascript">
        const canvas = document.getElementById("canvasOutput");
        const rect = canvas.getBoundingClientRect();

        canvas.addEventListener("click", function (event)
        {
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            console.log("x: " + x + ", y: " + y);
        });

        function onOpenCvReady()
        {
            cv['onRuntimeInitialized'] = () =>
            {
                document.getElementById('status').innerHTML = 'OpenCV.js is ready.';

                let video = document.getElementById('videoInput');
                let cap = new cv.VideoCapture(video);

                // parameters for ShiTomasi corner detection
                let [maxCorners, qualityLevel, minDistance, blockSize] = [30, 0.3, 7, 7];

                // parameters for lucas kanade optical flow
                let winSize = new cv.Size(15, 15);
                let maxLevel = 3;
                let criteria = new cv.TermCriteria();

                // create some random colors
                let color = [];
                for (let i = 0; i < maxCorners; i++)
                {
                    color.push(new cv.Scalar(parseInt(Math.random() * 255), parseInt(Math.random() * 255),
                        parseInt(Math.random() * 255), 255));
                }

                // take first frame and find corners in it
                let oldFrame = new cv.Mat(video.height, video.width, cv.CV_8UC4);
                cap.read(oldFrame);
                let oldGray = new cv.Mat();
                cv.cvtColor(oldFrame, oldGray, cv.COLOR_RGB2GRAY);
                // let p0 = cv.matFromArray(4, 1, cv.CV_32FC2, [350, 240, 444, 325, 435, 329, 459, 319]);
                let p0 = cv.matFromArray(2, 1, cv.CV_32FC2, [316, 284, 291, 368]);



                // let p0 = new cv.Mat();
                // let none = new cv.Mat();
                // cv.goodFeaturesToTrack(oldGray, p0, maxCorners, qualityLevel, minDistance, none, blockSize);
                console.log('image width: ' + p0.cols + '\n' +
                    'image height: ' + p0.rows + '\n' +
                    'image size: ' + p0.size().width + '*' + p0.size().height + '\n' +
                    'image depth: ' + p0.depth() + '\n' +
                    'image channels ' + p0.channels() + '\n' +
                    'image type: ' + p0.type() + '\n');



                // Create a mask image for drawing purposes
                let zeroEle = new cv.Scalar(0, 0, 0, 255);
                let mask = new cv.Mat(oldFrame.rows, oldFrame.cols, oldFrame.type(), zeroEle);

                let frame = new cv.Mat(video.height, video.width, cv.CV_8UC4);
                let frameGray = new cv.Mat();
                let p1 = new cv.Mat();
                let st = new cv.Mat();
                let err = new cv.Mat();

                const FPS = 60;

                // schedule the first one.
                setTimeout(processVideo, 0);

                function processVideo()
                {
                    try
                    {
                        let begin = Date.now();

                        // start processing.
                        cap.read(frame);
                        cv.cvtColor(frame, frameGray, cv.COLOR_RGBA2GRAY);

                        // calculate optical flow
                        let flow = new cv.Mat(oldGray.rows, oldGray.cols, cv.CV_32FC2);
                        cv.calcOpticalFlowFarneback(oldGray, frameGray, flow, 0.5, 3, 15, 3, 5, 1.2, 0);

                        for (let i = 0; i < p0.rows; i++)
                        {
                            let x = Math.round(p0.data32F[i * 2]);
                            let y = Math.round(p0.data32F[i * 2 + 1]);

                            let flowX = flow.data32F[(y * flow.cols + x) * 2];
                            let flowY = flow.data32F[(y * flow.cols + x) * 2 + 1];
                            console.log(Math.max(flow.data32F));

                            p0.data32F[i * 2] = x + flowX;
                            p0.data32F[i * 2 + 1] = y + flowY;
                            cv.circle(frame, new cv.Point(p0.data32F[i * 2], p0.data32F[i * 2 + 1]), 5, color[i], -1);
                        }

                        cv.add(frame, mask, frame);

                        cv.imshow('canvasOutput', frame);

                        // now update the previous frame and previous points
                        frameGray.copyTo(oldGray);

                        // schedule the next one.
                        let delay = 1000 / FPS - (Date.now() - begin);
                        setTimeout(processVideo, delay);
                    } catch (err)
                    {
                        console.error(err);
                    }
                };
            };

        }




    </script>
</body>

</html>